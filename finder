using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.MSBuild;
using Microsoft.CodeAnalysis.Text;
using ClosedXML.Excel; // dotnet add package ClosedXML

// -----------------------------------------------------------------------------
// Underwriting Usage Scanner — v5
// Changes in this version:
// - Enhanced ignore rules file (passed via --ignore-file) supports:
//    1) Plain project NAME              -> ignore everything from that project
//    2) Plain project PATH (.csproj)    -> ignore everything from that project (path literal or folder)
//    3) "<proj> <namespacePrefix>"     -> for the given project, ignore ONLY that namespace (prefix match)
//       - <proj> can be project name OR path to the .csproj (absolute or relative)
//       - <namespacePrefix> like Contoso.Contracts or Contoso.Contracts.Sub
//    4) Regex lines                     -> still supported; apply to proj name/path, assembly, namespace, symbol FQN, or definition file path
// - Folder-style paths end with a separator or no .csproj; those ignore any project whose csproj path starts with that folder.
// -----------------------------------------------------------------------------

internal static class Program
{
    private sealed record UsageHit(
        string UsingProject,
        string ReferencedProject,
        string File,
        int Line,
        string Method,
        string CodeLine);

    // ---- Ignore rule model ----
    private sealed class IgnoreRule
    {
        public string? ProjectNameLiteral { get; init; }        // case-insensitive exact match
        public string? ProjectPathLiteral { get; init; }        // normalized full path (project .csproj) or folder
        public string? NamespacePrefix { get; init; }           // case-insensitive prefix
        public Regex? Regex { get; init; }                      // fallback regex
    }

    private static async Task<int> Main(string[] args)
    {
        string solutionPath = GetArg(args, "--solution") ?? "all.sln";
        string underwritingProjectsFile = GetArg(args, "--underwriting-projects") ?? "underwriting-projects.txt";
        string ignoreFile = GetArg(args, "--ignore-file");
        string output = GetArg(args, "--output") ?? "underwriting-usages.xlsx";
        string format = (GetArg(args, "--format") ?? InferFormatFromOutput(output)).ToLowerInvariant(); // xlsx|csv|md

        solutionPath = Path.GetFullPath(solutionPath);
        if (!File.Exists(solutionPath))
        {
            Console.Error.WriteLine($"Solution not found: {solutionPath}");
            return 2;
        }

        var underwritingNames = LoadUnderwritingNames(underwritingProjectsFile);
        if (underwritingNames.Count == 0)
        {
            Console.Error.WriteLine("No underwriting projects provided. Put names in underwriting-projects.txt or pass --underwriting-projects.");
            return 2;
        }

        var ignoreRules = LoadIgnoreRules(ignoreFile);

        RegisterMsBuild();
        using var workspace = MSBuildWorkspace.Create();
        workspace.WorkspaceFailed += (_, e) => Console.Error.WriteLine("[MSBuild] " + e.Diagnostic);

        Console.WriteLine($"Loading solution: {solutionPath}");
        var solution = await workspace.OpenSolutionAsync(solutionPath);

        var allProjects = solution.Projects.Where(p => !string.IsNullOrEmpty(p.FilePath)).ToList();
        var underwritingProjects = allProjects.Where(p => underwritingNames.Contains(p.Name)).ToList();
        if (underwritingProjects.Count == 0)
        {
            Console.Error.WriteLine("Underwriting project names did not match any projects in the solution.");
            Console.Error.WriteLine("Projects available:\n  - " + string.Join("\n  - ", allProjects.Select(p => p.Name).OrderBy(s => s)));
            return 2;
        }

        // AssemblyName -> Project map
        var projByAssembly = allProjects
            .Where(p => !string.IsNullOrEmpty(p.AssemblyName))
            .GroupBy(p => p.AssemblyName!, StringComparer.OrdinalIgnoreCase)
            .ToDictionary(g => g.Key, g => g.First(), StringComparer.OrdinalIgnoreCase);

        var hits = new List<UsageHit>(capacity: 4096);

        foreach (var usingProject in underwritingProjects)
        {
            var compilation = await usingProject.GetCompilationAsync();
            if (compilation is null) continue;

            foreach (var doc in usingProject.Documents.Where(d => d.SourceCodeKind == SourceCodeKind.Regular && d.SupportsSyntaxTree))
            {
                var tree = await doc.GetSyntaxTreeAsync();
                if (tree is null) continue;
                var model = await doc.GetSemanticModelAsync();
                if (model is null) continue;

                var root = await tree.GetRootAsync();
                var text = await doc.GetTextAsync();

                var nodes = root.DescendantNodes().Where(n =>
                    n is Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax ||
                    n is Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax ||
                    n is Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax ||
                    n is Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax ||
                    n is Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax);

                foreach (var node in nodes)
                {
                    var info = model.GetSymbolInfo(node);
                    var symbol = info.Symbol ?? info.CandidateSymbols.FirstOrDefault();
                    if (symbol is null) continue;
                    symbol = symbol.OriginalDefinition;

                    var asm = symbol.ContainingAssembly?.Name ?? string.Empty;
                    var defPath = GetDefinitionPath(symbol);
                    if (string.IsNullOrEmpty(defPath)) continue; // metadata-only

                    if (!projByAssembly.TryGetValue(asm, out var defProj)) continue; // unknown
                    if (underwritingNames.Contains(defProj.Name)) continue; // internal reference

                    var ns = symbol.ContainingNamespace?.ToDisplayString() ?? string.Empty;
                    var defProjPath = defProj.FilePath ?? string.Empty;

                    if (IsIgnored(ignoreRules, defProj.Name, defProjPath, ns, asm, GetDisplay(symbol), defPath))
                        continue;

                    var linePos = tree.GetLineSpan(node.Span).StartLinePosition;
                    int line = linePos.Line + 1;
                    string codeLine = SafeGetLine(text, linePos.Line).Trim();
                    string method = GetEnclosingMember(model, node.SpanStart);

                    hits.Add(new UsageHit(
                        UsingProject: usingProject.Name,
                        ReferencedProject: defProj.Name,
                        File: doc.FilePath ?? string.Empty,
                        Line: line,
                        Method: method,
                        CodeLine: codeLine
                    ));
                }
            }
        }

        // Sort
        hits = hits
            .OrderBy(h => h.UsingProject, StringComparer.OrdinalIgnoreCase)
            .ThenBy(h => h.ReferencedProject, StringComparer.OrdinalIgnoreCase)
            .ThenBy(h => h.File, StringComparer.OrdinalIgnoreCase)
            .ThenBy(h => h.Line)
            .ToList();

        Directory.CreateDirectory(Path.GetDirectoryName(Path.GetFullPath(output)) ?? ".");

        switch (format)
        {
            case "xlsx":
                WriteExcel(hits, output);
                Console.WriteLine($"Wrote {hits.Count} rows to workbook: {output}");
                break;
            case "csv":
                File.WriteAllText(output, ToCsv(hits));
                Console.WriteLine($"Wrote {hits.Count} rows to {output}");
                break;
            case "md":
                File.WriteAllText(output, ToMarkdown(hits));
                Console.WriteLine($"Wrote {hits.Count} rows to {output}");
                break;
            default:
                Console.Error.WriteLine($"Unknown format: {format}");
                return 2;
        }

        return 0;
    }

    // -------------------------- Ignore rules --------------------------
    private static List<IgnoreRule> LoadIgnoreRules(string? ignoreFile)
    {
        var rules = new List<IgnoreRule>();
        if (string.IsNullOrWhiteSpace(ignoreFile) || !File.Exists(ignoreFile)) return rules;

        foreach (var raw in File.ReadAllLines(ignoreFile))
        {
            var line = raw.Trim();
            if (line.Length == 0 || line.StartsWith("#")) continue;

            // 1) Quoted project name/path with spaces: "My Project" Contoso.Ns
            var m = Regex.Match(line, "^\"(?<proj>[^\"]+)\"\s+(?<ns>.+)$");
            if (m.Success)
            {
                var projToken = m.Groups["proj"].Value.Trim();
                var nsPrefix = m.Groups["ns"].Value.Trim();
                rules.Add(BuildProjectScopedRule(projToken, nsPrefix));
                continue;
            }

            // 2) Unquoted: split on first whitespace -> <projToken> <namespaceOrNothing>
            int ws = line.IndexOfAny(new[] { ' ', '	' });
            if (ws > 0)
            {
                var projToken = line.Substring(0, ws).Trim();
                var nsPrefix = line.Substring(ws + 1).Trim();
                if (nsPrefix.Length > 0)
                {
                    rules.Add(BuildProjectScopedRule(projToken, nsPrefix));
                    continue;
                }
            }

            // 3) Single token line: could be project name, project/folder path, or regex
            var token = line;
            if (LooksLikePath(token))
            {
                rules.Add(new IgnoreRule { ProjectPathLiteral = NormalizePathForMatch(token) });
            }
            else if (MaybeRegex(token))
            {
                rules.Add(new IgnoreRule { Regex = new Regex(token, RegexOptions.IgnoreCase | RegexOptions.Compiled) });
            }
            else
            {
                rules.Add(new IgnoreRule { ProjectNameLiteral = token });
            }
        }
        return rules;
    }

    private static bool LooksLikePath(string token)
    {
        return token.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase) ||
               token.Contains('/') || token.Contains('\\');
    }

    private static bool MaybeRegex(string token)
    {
        // Heuristic: if it has regex-y chars, treat as regex
        return token.Contains("^") || token.Contains("$") || token.Contains("(") || token.Contains("[") || token.Contains("|") || token.Contains("?") || token.Contains("+") || token.Contains("{");
    }

    private static string NormalizePathForMatch(string p)
    {
        try
        {
            var full = Path.GetFullPath(p);
            return full.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
        }
        catch { return p; }
    }

    private static bool IsIgnored(List<IgnoreRule> rules, string defProjectName, string defProjectPath, string ns, string asm, string symbolFqn, string defPath)
    {
        defProjectPath = NormalizePathForMatch(defProjectPath ?? string.Empty);
        defPath = NormalizePathForMatch(defPath ?? string.Empty);

        foreach (var r in rules)
        {
            if (r.Regex != null)
            {
                if (r.Regex.IsMatch(defProjectName) || r.Regex.IsMatch(defProjectPath) || r.Regex.IsMatch(ns) || r.Regex.IsMatch(asm) || r.Regex.IsMatch(symbolFqn) || r.Regex.IsMatch(defPath))
                    return true;
                continue;
            }

            bool projMatch = false;
            if (!string.IsNullOrEmpty(r.ProjectNameLiteral))
            {
                projMatch = string.Equals(defProjectName, r.ProjectNameLiteral, StringComparison.OrdinalIgnoreCase);
            }
            else if (!string.IsNullOrEmpty(r.ProjectPathLiteral))
            {
                var lit = NormalizePathForMatch(r.ProjectPathLiteral);
                // exact file match or folder prefix match
                projMatch = string.Equals(defProjectPath, lit, StringComparison.OrdinalIgnoreCase) ||
                            (defProjectPath.StartsWith(lit + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase));
            }
            else
            {
                // No project constraint; treat as global (shouldn't happen here since regex handles that)
                projMatch = true;
            }

            if (!projMatch) continue;

            // If a namespace prefix is specified, require it
            if (!string.IsNullOrEmpty(r.NamespacePrefix))
            {
                if (ns.StartsWith(r.NamespacePrefix, StringComparison.OrdinalIgnoreCase))
                    return true;
                continue; // project matched but namespace didn't; don't ignore
            }

            // Project matched and no namespace restriction => ignore
            return true;
        }

        return false;
    }

    // -------------------------- Excel output --------------------------
    private sealed record Row(
        string ReferencedProject,
        string File,
        int Line,
        string Method,
        string CodeLine);

    private static void WriteExcel(List<UsageHit> hits, string xlsxPath)
    {
        using var wb = new XLWorkbook();
        foreach (var group in hits.GroupBy(h => h.UsingProject, StringComparer.OrdinalIgnoreCase))
        {
            var ws = wb.Worksheets.Add(SanitizeSheetName(group.Key));
            ws.Cell(1, 1).Value = "ReferencedProject";
            ws.Cell(1, 2).Value = "File";
            ws.Cell(1, 3).Value = "Line";
            ws.Cell(1, 4).Value = "Method";
            ws.Cell(1, 5).Value = "CodeLine";
            ws.Range(1, 1, 1, 5).Style.Font.Bold = true;

            int r = 2;
            foreach (var h in group)
            {
                ws.Cell(r, 1).Value = h.ReferencedProject;
                ws.Cell(r, 2).Value = Rel(h.File);
                ws.Cell(r, 3).Value = h.Line;
                ws.Cell(r, 4).Value = h.Method;
                ws.Cell(r, 5).Value = h.CodeLine;
                r++;
            }

            ws.Columns().AdjustToContents();
            ws.SheetView.FreezeRows(1);
        }
        wb.SaveAs(xlsxPath);
    }

    private static string SanitizeSheetName(string raw)
    {
        var name = raw;
        foreach (var c in new[] { '\\', '/', '*', '[', ']', ':', '?' })
            name = name.Replace(c, ' ');
        if (name.Length > 31) name = name.Substring(0, 31);
        return string.IsNullOrWhiteSpace(name) ? "Sheet" : name;
    }

    // -------------------------- helpers --------------------------
    private static void RegisterMsBuild()
    {
        var vs = MSBuildLocator.QueryVisualStudioInstances().OrderByDescending(i => i.Version).FirstOrDefault();
        if (vs != null)
        {
            MSBuildLocator.RegisterInstance(vs);
            return;
        }
        var dotnetRoot = Environment.GetEnvironmentVariable("DOTNET_ROOT");
#if WINDOWS
        dotnetRoot ??= @"C:\\Program Files\\dotnet";
#else
        dotnetRoot ??= Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".dotnet");
#endif
        var sdkDir = Path.Combine(dotnetRoot!, "sdk");
        var latest = Directory.Exists(sdkDir)
            ? Directory.GetDirectories(sdkDir).OrderByDescending(Path.GetFileName).FirstOrDefault()
            : null;
        if (latest is null) throw new Exception("No .NET SDK found. Install .NET SDK or VS Build Tools.");
        MSBuildLocator.RegisterMSBuildPath(latest);
    }

    private static HashSet<string> LoadUnderwritingNames(string file)
    {
        var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        if (!string.IsNullOrWhiteSpace(file) && File.Exists(file))
        {
            foreach (var raw in File.ReadAllLines(file))
            {
                var line = raw.Trim();
                if (line.Length == 0 || line.StartsWith("#")) continue;
                set.Add(line);
            }
        }
        return set;
    }

    private static string GetArg(string[] args, string name)
    {
        for (int i = 0; i < args.Length; i++)
        {
            if (string.Equals(args[i], name, StringComparison.OrdinalIgnoreCase))
            { return (i + 1 < args.Length) ? args[i + 1] : string.Empty; }
            if (args[i].StartsWith(name + "=", StringComparison.OrdinalIgnoreCase))
            { return args[i].Substring(name.Length + 1); }
        }
        return null!;
    }

    private static string InferFormatFromOutput(string output)
    {
        var ext = Path.GetExtension(output).ToLowerInvariant();
        return ext switch { 
            ".xlsx" => "xlsx",
            ".md" => "md",
            _ => "csv" };
    }

    private static string GetDefinitionPath(ISymbol symbol)
    {
        var loc = symbol.Locations.FirstOrDefault(l => l.IsInSource);
        return loc != null ? (loc.SourceTree?.FilePath ?? string.Empty) : string.Empty;
    }

    private static string GetDisplay(ISymbol s)
    {
        var format = new SymbolDisplayFormat(
            globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            memberOptions: SymbolDisplayMemberOptions.IncludeParameters | SymbolDisplayMemberOptions.IncludeContainingType,
            parameterOptions: SymbolDisplayParameterOptions.IncludeType | SymbolDisplayParameterOptions.IncludeName,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);
        return s.ToDisplayString(format);
    }

    private static string SafeGetLine(SourceText text, int zeroBasedLine)
        => (zeroBasedLine < 0 || zeroBasedLine >= text.Lines.Count) ? string.Empty : text.Lines[zeroBasedLine].ToString();

    private static string ToCsv(IEnumerable<UsageHit> hits)
    {
        var sb = new StringBuilder();
        sb.AppendLine("ReferencedProject,File,Line,Method,CodeLine");
        foreach (var h in hits)
        {
            sb.AppendLine(string.Join(',', new[]
            {
                Csv(h.ReferencedProject), Csv(Rel(h.File)), h.Line.ToString(), Csv(h.Method), Csv(h.CodeLine)
            }));
        }
        return sb.ToString();
    }

    private static string Csv(string s)
    {
        if (s is null) return string.Empty;
        if (s.Contains('"') || s.Contains(',') || s.Contains('\n'))
            return '"' + s.Replace("\"", "\"\"") + '"';
        return s;
    }

    private static string ToMarkdown(IEnumerable<UsageHit> hits)
    {
        var sb = new StringBuilder();
        sb.AppendLine("| Referenced Project | File | Line | Method | Code Line |");
        sb.AppendLine("|---|---|---:|---|---|");
        foreach (var h in hits)
        {
            sb.AppendLine($"| {Esc(h.ReferencedProject)} | {Esc(Rel(h.File))} | {h.Line} | {Esc(h.Method)} | {Esc(Trunc(h.CodeLine, 120))} |");
        }
        return sb.ToString();
    }

    private static string Rel(string path)
    {
        try { return Path.GetRelativePath(Directory.GetCurrentDirectory(), path); } catch { return path; }
    }

    private static string Trunc(string s, int max)
        => string.IsNullOrEmpty(s) || s.Length <= max ? s : s.Substring(0, max - 1) + "…";

    private static string Esc(string s) => s.Replace("|", "\\|");

    private static string GetEnclosingMember(SemanticModel model, int position)
    {
        var symbol = model.GetEnclosingSymbol(position);
        if (symbol == null) return string.Empty;
        ISymbol cur = symbol;
        while (cur != null && cur is not IMethodSymbol && cur is not IPropertySymbol && cur is not IEventSymbol && cur is not IFieldSymbol)
            cur = cur.ContainingSymbol;
        if (cur == null) cur = symbol.ContainingType ?? symbol;

        var fmt = new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            memberOptions: SymbolDisplayMemberOptions.IncludeParameters | SymbolDisplayMemberOptions.IncludeContainingType,
            parameterOptions: SymbolDisplayParameterOptions.IncludeType | SymbolDisplayParameterOptions.IncludeName);
        return cur.ToDisplayString(fmt);
    }
}
